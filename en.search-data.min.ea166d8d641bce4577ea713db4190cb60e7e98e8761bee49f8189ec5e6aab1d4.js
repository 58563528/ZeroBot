'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/start/install/',title:"快速安装",section:"Starts",content:"快速安装 #  安装Go #  首先需要安装Go(支持版本1.15+), 你可以在 Go官网  或者 Go中国镜像站  (国内用户推荐)找到对应的安装包\n下载和导入项目 #  本项目使用了GO111MOUDULE, 你需要使用Go模块集成管理(如果不会就用Goland帮你解决吧)\n使用下面指令下载源码\ngo get github.com/wdvxdr1123/ZeroBot 然后你就可以在项目中导入ZeroBot了!\nimport \u0026#34;github.com/wdvxdr1123/ZeroBot\u0026#34; "}),a.add({id:1,href:'/advanced/interact/',title:"Event Channel",section:"Advanceds",content:"Event Channel #  在 ZeroBot 中，提供了用于异步获取指定事件的方法，通过返回channel，搭配 go 语言的select和其他语言特性， 可以很轻松的实现交互式机器人。\n其核心为 FutureEvent，其定义如下\n// FutureEvent 是 ZeroBot 交互式的核心，用于异步获取指定事件 type FutureEvent struct { // 需要获取的事件类型  //  // 形如 message/group, 具体为 post_type / detail_type / sub_type  Type string // 优先级， 同 Matcher  Priority int // 同 Matcher  Rule []Rule // 同 Matcher  Block bool } 你可以使用 zero.NewFutureEvent 创建，或者使用matcher.FutureEvent来创建一个与当前matcher 优先级和阻断性相同的FutureEvent\nFutureEvent提供了两个基本方法，用于获取符合条件的事件。\nNext #  Next 返回一个 channel 用于接收下一个指定事件，并且该事件传输完成后，就会关闭该 channel,\n该 chan 必须接收，如需手动取消监听，请使用 Repeat 方法\nRepeat #  Repeat 返回一个 channel 用于接收无穷个指定事件，和一个取消监听的函数， 如果没有取消监听，将不断监听指定事件\n灵活使用 #  可以使用这些channel配合go强大的channel支持，组合出一些其他用法，如下面这个例子\n// Take 基于 Repeat 封装，返回一个 chan 接收指定数量的事件 // // 该 chan 对象必须接收，否则将有 goroutine 泄漏，如需手动取消请使用 Repeat func (n *FutureEvent) Take(num int) \u0026lt;-chan Event { recv, cancel := n.Repeat() ch := make(chan Event, num) go func() { defer close(ch) for i := 0; i \u0026lt; num; i++ { ch \u0026lt;- \u0026lt;-recv } cancel() }() return ch } 实战 #  例如 example 中的 复读例子\nzero.OnCommand(\u0026#34;开启复读\u0026#34;).SetBlock(true).SetPriority(10). Handle(func(matcher *zero.Matcher, event zero.Event, state zero.State) zero.Response { stop := zero.NewFutureEvent(\u0026#34;message/group\u0026#34;, 8, true, // 关闭指令要比复读指令优先级高  zero.CommandRule(\u0026#34;关闭复读\u0026#34;), // 关闭复读指令  zero.CheckUser(event.UserID)). // 只有开启者可以关闭复读模式  Next() // 关闭需要一次  echo, cancel := matcher.FutureEvent(\u0026#34;message/group\u0026#34;, // 优先级 和 开启复读指令相同  zero.CheckUser(event.UserID)). // 只复读开启复读模式的人的消息  Repeat() // 不断监听复读  zero.Send(event, \u0026#34;已开启复读模式!\u0026#34;) for { select { case e := \u0026lt;-echo: // 接收到需要复读的消息  zero.Send(event, e.RawMessage) case \u0026lt;-stop: // 收到关闭复读指令  cancel() // 取消复读监听  zero.Send(event, \u0026#34;已关闭复读模式!\u0026#34;) return zero.FinishResponse // 返回  } } }) 这里我们通过 for select 与 channel相配合，轻松的写出了一个可开启，关闭的复读插件\n"}),a.add({id:2,href:'/advanced/basic/',title:"Rule",section:"Advanceds",content:"Rule #  Rule 是ZeroBot过滤事件的核心,其定义如下所示\n// State store the context of a matcher. type State map[string]interface{} // Rule filter the event type Rule func(event *Event, state State) bool 其中 State 保存了在进行过滤事件中运算的结果，比如ZeroBot自带的 KeywordRule中，就将匹配到的关键词保存到了state[\u0026quot;keyword\u0026quot;]中\n// KeywordRule check if the message has a keyword or keywords func KeywordRule(src ...string) Rule { return func(event *Event, state State) bool { msg := event.Message.CQString() for _, str := range src { if strings.Contains(msg, str) { state[\u0026#34;keyword\u0026#34;] = str return true } } return false } } ZeroBot中自带了一些Rule，你可以在rule.go中找到它们\nMatcher #  Matcher是 ZeroBot 匹配事件的最小单元，其定义如下\ntype Matcher struct { // Temp 是否为临时Matcher，临时 Matcher 匹配一次后就会删除当前 Matcher  Temp bool // Block 是否阻断后续 Matcher，为 true 时当前Matcher匹配成功后，后续Matcher不参与匹配  Block bool // Priority 优先级，越小优先级越高  Priority int // State 上下文  State State // Event 当前匹配到的事件  Event *Event // Type 匹配的事件类型  Type Rule // Rules 匹配规则  Rules []Rule // Handler 处理事件的函数  Handler Handler } 在 ZeroBot 中，维护了一个有序的 MatcherList 每当接收一个新事件时，都会对MatcherList 中的每一Matcher逐一匹配，你可以通过zero.On函数向MatcherList添加一个Matcher\n同时 ZeroBot 也提供了一些其他函数，添加一些自带指定Rule的Matcher,例如\nzero.OnSuffix(\u0026#34;复读\u0026#34;) // 该Matcher自带 zero.SuffixRule(\u0026#34;复读“) Rule 你可以在 这里  查看其他自带的添加Matcher的函数\nHandler #  togu\n"}),a.add({id:3,href:'/start/quick_start/',title:"开始使用",section:"Starts",content:"最小化实例 #  创建一个新项目，启动Bot只需要main中使用下面代码\nfunc main() { zero.Run(zero.Option{ Host: \u0026#34;127.0.0.1\u0026#34;, // cqhttp的ip地址  Port: \u0026#34;6700\u0026#34;, // cqhttp的端口  AccessToken: \u0026#34;\u0026#34;, NickName: []string{\u0026#34;机器人的昵称\u0026#34;}, CommandPrefix: \u0026#34;/\u0026#34;, // 指令前缀  SuperUsers: []string{\u0026#34;123456\u0026#34;}, // 超级用户账号 一般填你自己的QQ号  }) select {} // 阻塞主goroutine, 防止退出程序  // 如果你的机器人有使用数据库或者其他资源文件,可以使用下面方法阻塞  /* c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt, os.Kill) \u0026lt;-c Release() // 释放资源 */ } 设置日志输出 #  在 ZeroBot 中使用了sirupsen/logrus来管理日志，但是并没有提供日志的模板，你可以自己定义日志输出模板， 如果想偷懒，这里给出一个简单的模板\nimport ( log \u0026#34;github.com/sirupsen/logrus\u0026#34; easy \u0026#34;github.com/t-tomalak/logrus-easy-formatter\u0026#34; ) func init() { log.SetFormatter(\u0026amp;easy.Formatter{ TimestampFormat: \u0026#34;2006-01-02 15:04:05\u0026#34;, LogFormat: \u0026#34;[zero][%time%][%lvl%]: %msg% \\n\u0026#34;, }) log.SetLevel(log.DebugLevel) } 添加一个插件 #  得益于 GO111MODULE 和 init 函数，在ZeroBot里添加一个插件十分简单，如果想要添加example代码中的插件，只需要\nimport _ \u0026#34;github.com/wdvxdr1123/ZeroBot/example/music\u0026#34; 添加这个导入后即可为你的机器人添加点歌插件\n编写一个插件 #  在 ZeroBot 中，插件是以接口的形式实现的\n// IPlugin is the plugin of the ZeroBot type IPlugin interface { // 获取插件信息  GetPluginInfo() PluginInfo // 开启工作  Start() } 编写一个插件你需要新建一个文件夹，然后自定义一个类型，为它实现IPlugin接口, 并在init函数中，注册该插件,例如\npackage test import ( \u0026#34;github.com/wdvxdr1123/ZeroBot\u0026#34; ) func init() { zero.RegisterPlugin(\u0026amp;testPlugin{}) // 注册插件 } type testPlugin struct{} func (_ *testPlugin) GetPluginInfo() zero.PluginInfo { // 返回插件信息  return zero.PluginInfo{ // 插件信息本身没什么用，但是可以方便别人了解你写的插件  Author: \u0026#34;wdvxdr1123\u0026#34;, // 作者  PluginName: \u0026#34;test\u0026#34;, // 插件名  Version: \u0026#34;0.1.0\u0026#34;, // 版本  Details: \u0026#34;这是一个测试插件\u0026#34;, // 插件信息  } } func (_ *testPlugin) Start() { // 插件主体  panic(\u0026#34;impl me\u0026#34;) } 编写一个复读插件 #  func (_ *testPlugin) Start() { // 插件主体  zero.OnCommand(\u0026#34;echo\u0026#34;).Handle(handleEcho) // 注册一个叫echo的指令，逻辑处理函数为 handleEcho } func handleEcho(_ *zero.Matcher, event zero.Event, state zero.State) zero.Response { zero.Send(event, state[\u0026#34;args\u0026#34;]) // 发送echo的参数  return zero.FinishResponse // 所有处理已完毕，返回Finish } "})})()