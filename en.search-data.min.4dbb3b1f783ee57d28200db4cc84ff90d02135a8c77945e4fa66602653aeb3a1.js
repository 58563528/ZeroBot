'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/start/install/','title':"快速安装",'section':"Starts",'content':"快速安装 #  安装Go #  首先需要安装Go(支持版本1.15+), 你可以在 Go官网  或者 Go中国镜像站  (国内用户推荐) 找到对应的安装包\n下载和导入项目 #  本项目使用了GO111MOUDULE, 你需要使用Go模块集成管理(如果不会就用Goland帮你解决吧)\n使用下面指令下载源码\ngo get github.com/wdvxdr1123/ZeroBot 然后你就可以在项目中导入ZeroBot了!\nimport \u0026#34;github.com/wdvxdr1123/ZeroBot\u0026#34; "});index.add({'id':1,'href':'/start/quick_start/','title':"First",'section':"Starts",'content':"开始使用 #  最小化实例 #  创建一个新项目，启动Bot只需要main中使用下面代码\nfunc main() { zero.Run(zero.Option{ Host: \u0026#34;127.0.0.1\u0026#34;, // cqhttp的ip地址  Port: \u0026#34;6700\u0026#34;, // cqhttp的端口  AccessToken: \u0026#34;\u0026#34;, NickName: []string{\u0026#34;机器人的昵称\u0026#34;}, CommandPrefix: \u0026#34;/\u0026#34;, // 指令前缀  SuperUsers: []string{\u0026#34;123456\u0026#34;}, // 超级用户账号 一般填你自己的QQ号  }) select {} // 阻塞主goroutine, 防止退出程序  // 如果你的机器人有使用数据库或者其他资源文件,可以使用下面方法阻塞  /* c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt, os.Kill) \u0026lt;-c Release() // 释放资源 */ } 设置日志输出 #  在 ZeroBot 中使用了sirupsen/logrus来管理日志，但是并没有提供日志的模板，你可以自己定义日志输出模板， 如果想偷懒，这里给出一个简单的模板\nimport ( log \u0026#34;github.com/sirupsen/logrus\u0026#34; easy \u0026#34;github.com/t-tomalak/logrus-easy-formatter\u0026#34; ) func init() { log.SetFormatter(\u0026amp;easy.Formatter{ TimestampFormat: \u0026#34;2006-01-02 15:04:05\u0026#34;, LogFormat: \u0026#34;[zero][%time%][%lvl%]: %msg% \\n\u0026#34;, }) log.SetLevel(log.DebugLevel) } 添加一个插件 #  得益于 GO111MODULE 和 init 函数，在ZeroBot里添加一个插件十分简单，如果想要添加example代码中的插件，只需要\nimport _ \u0026#34;github.com/wdvxdr1123/ZeroBot/example/music\u0026#34; 添加这个导入后即可为你的机器人添加点歌插件\n编写一个插件 #  在 ZeroBot 中，插件是以接口的形式实现的\n// IPlugin is the plugin of the ZeroBot type IPlugin interface { // 获取插件信息  GetPluginInfo() PluginInfo // 开启工作  Start() } 编写一个插件你需要新建一个文件夹，然后自定义一个类型，为它实现IPlugin接口, 并在init函数中，注册该插件,例如\npackage test import ( \u0026#34;github.com/wdvxdr1123/ZeroBot\u0026#34; ) func init() { zero.RegisterPlugin(\u0026amp;testPlugin{}) // 注册插件 } type testPlugin struct{} func (_ *testPlugin) GetPluginInfo() zero.PluginInfo { // 返回插件信息  return zero.PluginInfo{ // 插件信息本身没什么用，但是可以方便别人了解你写的插件  Author: \u0026#34;wdvxdr1123\u0026#34;, // 作者  PluginName: \u0026#34;test\u0026#34;, // 插件名  Version: \u0026#34;0.1.0\u0026#34;, // 版本  Details: \u0026#34;这是一个测试插件\u0026#34;, // 插件信息  } } func (_ *testPlugin) Start() { // 插件主体  panic(\u0026#34;impl me\u0026#34;) } 编写一个复读插件 #  func (_ *testPlugin) Start() { // 插件主体  zero.OnCommand(\u0026#34;echo\u0026#34;).Handle(handleEcho) // 注册一个叫echo的指令，逻辑处理函数为 handleEcho } func handleEcho(_ *zero.Matcher, event zero.Event, state zero.State) zero.Response { zero.Send(event, state[\u0026#34;args\u0026#34;]) // 发送echo的参数  return zero.FinishResponse // 所有处理已完毕，返回Finish } "});})();