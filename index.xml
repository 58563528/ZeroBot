<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZeroBot Document</title>
    <link>http://docs.wdvxdr.top/</link>
    <description>Recent content on ZeroBot Document</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 19 Jan 2021 16:43:41 +0800</lastBuildDate><atom:link href="http://docs.wdvxdr.top/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>快速安装</title>
      <link>http://docs.wdvxdr.top/start/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://docs.wdvxdr.top/start/install/</guid>
      <description>快速安装 #  安装Go #  首先需要安装Go(支持版本1.15+), 你可以在 Go官网  或者 Go中国镜像站  (国内用户推荐)找到对应的安装包
下载和导入项目 #  本项目使用了GO111MOUDULE, 你需要使用Go模块集成管理(如果不会就用Goland帮你解决吧)
使用下面指令下载源码
go get github.com/wdvxdr1123/ZeroBot 然后你就可以在项目中导入ZeroBot了!
import &amp;#34;github.com/wdvxdr1123/ZeroBot&amp;#34; </description>
    </item>
    
    <item>
      <title>Event Channel</title>
      <link>http://docs.wdvxdr.top/advanced/interact/</link>
      <pubDate>Tue, 19 Jan 2021 16:43:41 +0800</pubDate>
      
      <guid>http://docs.wdvxdr.top/advanced/interact/</guid>
      <description>Event Channel #  在 ZeroBot 中，提供了用于异步获取指定事件的方法，通过返回channel，搭配 go 语言的select和其他语言特性， 可以很轻松的实现交互式机器人。
其核心为 FutureEvent，其定义如下
// FutureEvent 是 ZeroBot 交互式的核心，用于异步获取指定事件 type FutureEvent struct { // 需要获取的事件类型  //  // 形如 message/group, 具体为 post_type / detail_type / sub_type  Type string // 优先级， 同 Matcher  Priority int // 同 Matcher  Rule []Rule // 同 Matcher  Block bool } 你可以使用 zero.NewFutureEvent 创建，或者使用matcher.FutureEvent来创建一个与当前matcher 优先级和阻断性相同的FutureEvent
FutureEvent提供了两个基本方法，用于获取符合条件的事件。
Recv #  Next 返回一个 channel 用于接收下一个指定事件，并且该事件传输完成后，就会关闭该 channel,</description>
    </item>
    
    <item>
      <title>Rule</title>
      <link>http://docs.wdvxdr.top/advanced/basic/</link>
      <pubDate>Tue, 29 Dec 2020 13:55:32 +0800</pubDate>
      
      <guid>http://docs.wdvxdr.top/advanced/basic/</guid>
      <description>Rule #  Rule 是ZeroBot过滤事件的核心,其定义如下所示
// State store the context of a matcher. type State map[string]interface{} // Rule filter the event type Rule func(event *Event, state State) bool 其中 State 保存了在进行过滤事件中运算的结果，比如ZeroBot自带的 KeywordRule中，就将匹配到的关键词保存到了state[&amp;quot;keyword&amp;quot;]中
// KeywordRule check if the message has a keyword or keywords func KeywordRule(src ...string) Rule { return func(event *Event, state State) bool { msg := event.Message.CQString() for _, str := range src { if strings.Contains(msg, str) { state[&amp;#34;keyword&amp;#34;] = str return true } } return false } } ZeroBot中自带了一些Rule，你可以在rule.</description>
    </item>
    
    <item>
      <title>开始使用</title>
      <link>http://docs.wdvxdr.top/start/quick_start/</link>
      <pubDate>Sat, 26 Dec 2020 12:57:28 +0800</pubDate>
      
      <guid>http://docs.wdvxdr.top/start/quick_start/</guid>
      <description>最小化实例 #  创建一个新项目，启动Bot只需要main中使用下面代码
func main() { zero.Run(zero.Option{ Host: &amp;#34;127.0.0.1&amp;#34;, // cqhttp的ip地址  Port: &amp;#34;6700&amp;#34;, // cqhttp的端口  AccessToken: &amp;#34;&amp;#34;, NickName: []string{&amp;#34;机器人的昵称&amp;#34;}, CommandPrefix: &amp;#34;/&amp;#34;, // 指令前缀  SuperUsers: []string{&amp;#34;123456&amp;#34;}, // 超级用户账号 一般填你自己的QQ号  }) select {} // 阻塞主goroutine, 防止退出程序  // 如果你的机器人有使用数据库或者其他资源文件,可以使用下面方法阻塞  /* c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt, os.Kill) &amp;lt;-c Release() // 释放资源 */ } 设置日志输出 #  在 ZeroBot 中使用了sirupsen/logrus来管理日志，但是并没有提供日志的模板，你可以自己定义日志输出模板， 如果想偷懒，这里给出一个简单的模板
import ( log &amp;#34;github.com/sirupsen/logrus&amp;#34; easy &amp;#34;github.</description>
    </item>
    
  </channel>
</rss>
